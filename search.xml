<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 版本控制系统</title>
      <link href="2020/09/25/git/"/>
      <url>2020/09/25/git/</url>
      
        <content type="html"><![CDATA[<!-- 鼠标跟随 --><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script><h2 id="菜鸟都能懂的git"><a class="markdownIt-Anchor" href="#菜鸟都能懂的git"></a> 菜鸟都能懂的git</h2><p><em>这是我个人博客的第一篇文章，因为最近学习了一下git，然后就想着做一个整理，因为命令经常忘记，所以本篇文章将会重点对git命令进行梳理和运用。</em></p><blockquote><p><strong>git init</strong> 初始化一个Git仓库<br /><em><strong>git add <file></strong></em> 添加文件到暂存区<br /><em><strong>git commit -m <message></strong></em><br /><em><strong>git status</strong></em> 查看状态<br /><em><strong>HEAD</strong></em> 指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 <em><strong>git reset --hard commit_id</strong></em> 。<br />穿梭前，用 <em><strong>git log</strong></em> 可以查看提交历史，以便确定要回退到哪个版本。<br />要重返未来，用 <em><strong>git reflog</strong></em> 查看命令历史，以便确定要回到未来的哪个版本。</p></blockquote><hr /><ul><li><em><strong>首先我们要了解什么是版本控制系统</strong></em></li></ul><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：<br />想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><div><img src="https://i.loli.net/2020/09/25/3BE1rkHix4SCVDK.png" style="margin-left:45px"width="50%"></div>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。             <p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><img src="https://i.loli.net/2020/09/25/59ZkrovQYwMaGSf.png">  这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。   <h3 id="创建版本库"><a class="markdownIt-Anchor" href="#创建版本库"></a> 创建版本库</h3><blockquote><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">&#x2F;Users&#x2F;michael&#x2F;learngit         </span><br></pre></td></tr></table></figure><p>pwd命令用于显示当前目录(确保自己路径不会包含中文)。</p><p>第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>现在我们编写一个readme.txt文件，内容如下：</p><blockquote><p>Git is a version control system.<br />Git is free software.</p></blockquote><p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><pre><code>$ git add readme.txt   </code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><h3 id="创建版本库-2"><a class="markdownIt-Anchor" href="#创建版本库-2"></a> 创建版本库</h3><blockquote><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><blockquote><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">&#x2F;Users&#x2F;michael&#x2F;learngit</span><br></pre></td></tr></table></figure><p>pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。</p><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。<br />第二步，通过git init命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>言归正传，现在我们编写一个readme.txt文件，内容如下：</p><blockquote><p>Git is a version control system.<br />Git is free software.<br />一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p></blockquote><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><pre><code>$ git add readme.txt</code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><blockquote><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p></blockquote><blockquote><p>嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p></blockquote><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><h3 id="时光穿梭机"><a class="markdownIt-Anchor" href="#时光穿梭机"></a> 时光穿梭机</h3><p>要随时掌握工作区的状态，使用git status命令。</p><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><h4 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h4><blockquote><p>当你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p></blockquote><blockquote><p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p></blockquote><blockquote><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p></blockquote><blockquote><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD<sup>，上上一个版本就是HEAD</sup><sup>，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100。</p></blockquote><blockquote><p>我们要把当前版本回退到上一个版本，就可以使用git reset命令：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p>我们想要再回去只需要找到id就好了。</p><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向第三个版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ 第三个版本</span><br><span class="line">        │</span><br><span class="line">        ○ 第二个版本</span><br><span class="line">        │</span><br><span class="line">        ○ 第一个版本</span><br></pre></td></tr></table></figure><p>改为指向第二个版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ 第三个版本</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ 第二个版本</span><br><span class="line">        │</span><br><span class="line">        ○ 第一个版本</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到第二个版本时，再想恢复到第三个版本时，就必须找到第三个版本的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，第三个版本的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。</p><h4 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>stage就是暂存区。我们写的文件首先就是在工作区，通过git add命令将文件上传到暂存区，一个暂存区可以有多个文件，然后通过git commit命令上传到版本库</p><h2 id="img-srchttpsftpbmpovhimgs202009ac4abbced80b9121jpg"><a class="markdownIt-Anchor" href="#img-srchttpsftpbmpovhimgs202009ac4abbced80b9121jpg"></a> <img src="https://ftp.bmp.ovh/imgs/2020/09/ac4abbced80b9121.jpg"></h2><h3 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h3><h3 id="分支仓库"><a class="markdownIt-Anchor" href="#分支仓库"></a> 分支仓库</h3><h3 id="标签仓库"><a class="markdownIt-Anchor" href="#标签仓库"></a> 标签仓库</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
